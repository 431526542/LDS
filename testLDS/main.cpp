#include<iostream>
#include"Arr1.h"
#include"LinkedList1.h"

struct tMy
{

};

class cMy
{
	/*
	* 접근제한지정자(private,protected(상속),public)
	* 생성자,소멸자라는 초기화 함수 제공(반환타입없음)-> 객체가 만들어 질때 호출 됨, 반드시 존재해야함
	*/
private:
	int m_i;
	float m_f;

public:

	void SetInt(int i)//클래스에서 지장한 맴버함수도 끈다.
	{
		m_i = i;
	}

	//대입연산자
	//이건 클래스 자동생성 객체 = 객체 할 때 생성
	//c3 = c2 일때 _Other에 c2객체를 참조받아서 온것 ->대입시키는것이기때문에 c2객체의 값은 건들어면 안됨
	//그래서 const cMy&즉. const cMy const 처럼 수정이 불가능하지만 값은 받아올 수 있게 하는것이다.
	cMy& operator =(const cMy& _Other)
	{
		m_i = _Other.m_i;
		m_f = _Other.m_f;

		return *this; //반환타입없이 void operator = (...)이런식으로 만들면 c=c2=c3이면 c = ;이렇게 된다. 즉 계산만 되고 끝난다는것 계산만하고 반환하지않는다는것
		//원본 객체의 c2를 보는거고 c2를 참조해서 돌려주는 것
	}




public:
	//생성자 (:<-이니셜라이저 진짜 초기화)
	cMy() : m_i(1), m_f(0.2f)
	{

	}

	//소멸자(main함수 종료시점에 출력)
	~cMy()
	{

	}
};


int main()
{
	//클레스 특징
	/*
	*(구조체->사용자가 직접 정의한 자료형)
	*(클래스-> 사용자가 직접 정의한 자료형)
	* 1.생성자,소멸자 -> 객체 생성, 소멸 시 자동으로 호출, 직접 만들지 않으면 기본 생성자 소멸자로 생성됨 
	* 2.맴버함수 -> 해당클래스가 사용하는 전용함수 ex)cMy:: 라고 입력-> 그냥호출 할 수 없다. 해당 클래스의 객체가 필요함
	*	(특징) 객체를 통해서 호출하면, 해당 객체의 주소가 this 포인터로 전달 된다.
	* 3.접근제한지장자-> 클래스내의 맴버변수 또는 맴버함수의 접근 여부
	*/

	/*
	[레퍼런스]
	자료형* 변수명;->변수는 자료형의 포인터 타입 변수이다. [포인터변수선언]
	*포인터변수; ->포인터 변수에 저장되어있는 주소로 역참조 [포인터로 주소 역참조]
	&변수;->본인의 주소값을 반환 [변수의 주소값]
	자료형& 변수명-> [레퍼런스 변수선언]
	포인터와유사(포인터와 다른점-> 참조변수를 통해서 직접적으로 원본을 수정 할 수 있다.)
	원본을 참조한다.
	*/
	{
		int a = 10;

		int* p = &a; // p는 a변수의 주소만 가르킨다. 다른변수가르킬 수 없다.
		*p = 100;

		int& iRef = a; //iRef는 a변수만 참조한다. 그래서 iRef의 값을 변경하면 a를 변경한 걸로 친다.
		iRef = 100;  //매번 포인터로역참조 연산을 해줘야 원본으로 접근할 수있는 포인터 변수와 달리 본인이 참조받자마자 바로 자기가 변수를 즉시 수정 할수 있는 형태
		// 내가 원하는 형태의 함수를 설계하는데 있어서 중요하다.
	}
	

	cMy c;
	c.SetInt(10);
	cMy c2;
	c2.SetInt(100);

	c = c2;
	
	return 0;
}